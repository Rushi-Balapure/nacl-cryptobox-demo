import base64
import binascii
import json
import os
import platform
import hashlib

import requests
from cryptography.hazmat.primitives.asymmetric import ed25519, x25519
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305


SERVER_URL = "http://127.0.0.1:5001"
DEVICE_ID_PATH = "device_id_crypto.txt"


def derive_session_key(shared_secret: bytes) -> bytes:
    """
    Derive a 32-byte symmetric key from an X25519 shared secret.
    """
    hkdf = HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=None,
        info=b"device-trust-ecdh",
    )
    return hkdf.derive(shared_secret)


# --- CONFIGURATION ---
# Load Long-Term Agent Private Key (Ed25519), generated by keygen_crypto.py
with open("agent_crypto.pri", "rb") as f:
    _agent_priv_hex = f.read().strip()
_agent_priv_bytes = binascii.unhexlify(_agent_priv_hex)
AGENT_PRI = ed25519.Ed25519PrivateKey.from_private_bytes(_agent_priv_bytes)

AGENT_PUB = AGENT_PRI.public_key()
AGENT_PUB_HEX = binascii.hexlify(
    AGENT_PUB.public_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PublicFormat.Raw,
    )
).decode()


def load_or_register_device() -> str:
    """
    Ensure this agent has a device_id by registering its public key with the server once.
    """
    if os.path.exists(DEVICE_ID_PATH):
        with open(DEVICE_ID_PATH, "r", encoding="utf-8") as f:
            device_id = f.read().strip()
            if device_id:
                return device_id

    device_info = {
        "os": platform.system(),
        "release": platform.release(),
        "hostname": platform.node(),
    }
    payload = {
        "device_public_key": AGENT_PUB_HEX,
        "device_info": device_info,
    }
    print("[AGENT-CRYPTO] Registering device with server...")
    res = requests.post(f"{SERVER_URL}/register_device", json=payload, timeout=5)
    res.raise_for_status()
    data = res.json()
    device_id = data["device_id"]

    with open(DEVICE_ID_PATH, "w", encoding="utf-8") as f:
        f.write(device_id)

    print(f"[AGENT-CRYPTO] Registered device_id={device_id}")
    return device_id


def fetch_server_verify_key() -> ed25519.Ed25519PublicKey:
    """
    Fetch the server's long-term public key from the /server_pub endpoint.
    """
    print("[AGENT-CRYPTO] Fetching server public key...")
    res = requests.get(f"{SERVER_URL}/server_pub", timeout=5)
    res.raise_for_status()
    data = res.json()
    server_pub_hex = data["server_public_key"]
    server_pub_bytes = binascii.unhexlify(server_pub_hex)
    return ed25519.Ed25519PublicKey.from_public_bytes(server_pub_bytes)


def run_agent():
    device_id = load_or_register_device()
    server_verify_key = fetch_server_verify_key()

    # --- Step 3 (Receive) ---
    print("[AGENT-CRYPTO] Requesting handshake...")
    response = requests.post(
        f"{SERVER_URL}/handshake/init",
        json={"device_id": device_id},
        timeout=5,
    )
    response.raise_for_status()
    data = response.json()

    signed_envelope = base64.b64decode(data["signed_envelope"])

    # --- Step 4: Verify Server Signature ---
    try:
        signature = signed_envelope[:64]
        message_bytes = signed_envelope[64:]
        server_verify_key.verify(signature, message_bytes)
        server_payload = json.loads(message_bytes.decode("utf-8"))
        print("[AGENT-CRYPTO] Server Signature Verified.")
    except Exception:
        print("[AGENT-CRYPTO] Error: Fake Server Detected!")
        return

    # Extract Data
    challenge = base64.b64decode(server_payload["challenge"])
    server_eph_pub_bytes = base64.b64decode(server_payload["server_eph_pub"])
    server_eph_pub = x25519.X25519PublicKey.from_public_bytes(server_eph_pub_bytes)
    session_id = server_payload["session_id"]

    # --- Step 5: Generate Agent Ephemeral Keys ---
    agent_eph_pri = x25519.X25519PrivateKey.generate()
    agent_eph_pub = agent_eph_pri.public_key()

    # --- Step 6: Generate ECDH Key ---
    shared_secret = agent_eph_pri.exchange(server_eph_pub)
    ecdh_key = derive_session_key(shared_secret)

    # --- Step 7: Solve Challenge ---
    challenge_response = hashlib.sha256(challenge).digest()

    # --- Step 8: Prepare Inner Box (Crypto-Box) ---
    inner_payload = {
        "challenge_response": base64.b64encode(challenge_response).decode("utf-8"),
        "agent_pub_long_term": AGENT_PUB_HEX,
        "device_attestations": {
            "os": platform.system(),
            "release": platform.release(),
            "hostname": platform.node(),
        },
        "secret_message": "Hello Server (cryptography version), this is a secure trust channel!",
    }

    aead = ChaCha20Poly1305(ecdh_key)
    nonce = os.urandom(12)
    ciphertext = aead.encrypt(nonce, json.dumps(inner_payload).encode("utf-8"), None)
    encrypted_inner_b64 = base64.b64encode(nonce + ciphertext).decode("utf-8")

    # --- Step 9: Prepare Outer Box ---
    agent_eph_pub_bytes = agent_eph_pri.public_key().public_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PublicFormat.Raw,
    )
    outer_payload = {
        "session_id": session_id,
        "inner_box": encrypted_inner_b64,
        "agent_eph_pub": base64.b64encode(agent_eph_pub_bytes).decode("utf-8"),
    }

    # Sign Outer Box with Agent Long-term Key
    outer_bytes = json.dumps(outer_payload).encode("utf-8")
    outer_sig = AGENT_PRI.sign(outer_bytes)
    signed_outer = outer_sig + outer_bytes

    # --- Step 10: Forward to Server ---
    final_payload = {
        "outer_envelope": base64.b64encode(signed_outer).decode("utf-8"),
        "device_id": device_id,
    }

    print("[AGENT-CRYPTO] Sending encrypted proofs...")
    res = requests.post(
        f"{SERVER_URL}/handshake/verify",
        json=final_payload,
        timeout=5,
    )
    res.raise_for_status()
    verify_result = res.json()
    print(f"[AGENT-CRYPTO] Server Handshake Response: {verify_result}")

    if verify_result.get("status") != "trusted":
        print("[AGENT-CRYPTO] Handshake failed; aborting secure message.")
        return

    session_id = verify_result["session_id"]

    # --- Secure message over established session key ---
    secure_box = ChaCha20Poly1305(ecdh_key)
    message = "Hello Server (cryptography version), this is a post-handshake secure message."
    nonce2 = os.urandom(12)
    ct2 = secure_box.encrypt(nonce2, message.encode("utf-8"), None)
    ciphertext_b64 = base64.b64encode(nonce2 + ct2).decode("utf-8")

    secure_payload = {
        "session_id": session_id,
        "ciphertext": ciphertext_b64,
    }

    print("[AGENT-CRYPTO] Sending secure message over session...")
    secure_res = requests.post(
        f"{SERVER_URL}/secure_message",
        json=secure_payload,
        timeout=5,
    )
    secure_res.raise_for_status()
    print(f"[AGENT-CRYPTO] Secure message response: {secure_res.json()}")


if __name__ == "__main__":
    run_agent()


