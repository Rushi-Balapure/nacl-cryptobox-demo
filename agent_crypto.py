import base64
import binascii
import json
import os
import platform
import hashlib

import requests
from cryptography.hazmat.primitives.asymmetric import ed25519, x25519
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305


SERVER_URL = "http://127.0.0.1:5001"
DEVICE_ID_PATH = "device_id_crypto.txt"

# REG_TOKEN is the out-of-band shared secret entered by the user.
# For this demo we read it from the environment or fall back to a static value.
REG_TOKEN = os.environ.get("REG_TOKEN", "demo-reg-token-1234")


def derive_session_key(shared_secret: bytes) -> bytes:
    """
    Derive a 32-byte symmetric key from an X25519 shared secret.
    """
    hkdf = HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=None,
        info=b"device-trust-ecdh",
    )
    return hkdf.derive(shared_secret)


def derive_binding_key(reg_token: str) -> bytes:
    """
    Derive a 32-byte symmetric key from the REG_TOKEN using HKDF,
    matching the registration KDF described in the README.
    """
    hkdf = HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=b"registration_v1",
        info=b"device_binding",
    )
    return hkdf.derive(reg_token.encode("utf-8"))


def compute_reg_handle(binding_key: bytes) -> str:
    """
    Compute an opaque registration handle from the binding key.
    """
    return hashlib.sha256(binding_key).hexdigest()[:32]


# --- CONFIGURATION ---
# Load Long-Term Agent Private Key (Ed25519), generated by keygen_crypto.py
with open("agent_crypto.pri", "rb") as f:
    _agent_priv_hex = f.read().strip()
_agent_priv_bytes = binascii.unhexlify(_agent_priv_hex)
AGENT_PRI = ed25519.Ed25519PrivateKey.from_private_bytes(_agent_priv_bytes)

AGENT_PUB = AGENT_PRI.public_key()
AGENT_PUB_HEX = binascii.hexlify(
    AGENT_PUB.public_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PublicFormat.Raw,
    )
).decode()


def load_or_register_device() -> str:
    """
    Phase I – Steps 2 & 3 (Agent side):
    Ensure this agent has a device_id by registering its public key with the server once,
    using an encrypted payload bound to the REG_TOKEN.
    """
    if os.path.exists(DEVICE_ID_PATH):
        with open(DEVICE_ID_PATH, "r", encoding="utf-8") as f:
            device_id = f.read().strip()
            if device_id:
                return device_id

    device_info = {
        "os": platform.system(),
        "release": platform.release(),
        "hostname": platform.node(),
    }

    binding_key = derive_binding_key(REG_TOKEN)
    reg_handle = compute_reg_handle(binding_key)

    inner_payload = {
        "device_public_key": AGENT_PUB_HEX,
        "device_info": device_info,
    }

    aead = ChaCha20Poly1305(binding_key)
    nonce = os.urandom(12)
    ciphertext = aead.encrypt(nonce, json.dumps(inner_payload).encode("utf-8"), None)
    encrypted_payload = base64.b64encode(nonce + ciphertext).decode("utf-8")

    payload = {
        "reg_handle": reg_handle,
        "encrypted_payload": encrypted_payload,
    }

    print("[AGENT-CRYPTO] Registering device with server (encrypted binding)...")
    res = requests.post(f"{SERVER_URL}/register_device", json=payload, timeout=5)
    res.raise_for_status()
    data = res.json()
    device_id = data["device_id"]

    with open(DEVICE_ID_PATH, "w", encoding="utf-8") as f:
        f.write(device_id)

    print(f"[AGENT-CRYPTO] Registered device_id={device_id}")
    return device_id


def fetch_server_verify_key() -> ed25519.Ed25519PublicKey:
    """
    Fetch the server's long-term public key from the /server_pub endpoint.
    """
    print("[AGENT-CRYPTO] Fetching server public key...")
    res = requests.get(f"{SERVER_URL}/server_pub", timeout=5)
    res.raise_for_status()
    data = res.json()
    server_pub_hex = data["server_public_key"]
    server_pub_bytes = binascii.unhexlify(server_pub_hex)
    return ed25519.Ed25519PublicKey.from_public_bytes(server_pub_bytes)


def run_agent():
    device_id = load_or_register_device()
    server_verify_key = fetch_server_verify_key()

    # Phase II – Step 5: Request CHALLENGE and server-ephemeral.pub from the server.
    print("[AGENT-CRYPTO] Requesting handshake...")
    response = requests.post(
        f"{SERVER_URL}/handshake/init",
        json={"device_id": device_id},
        timeout=5,
    )
    response.raise_for_status()
    data = response.json()

    signed_envelope = base64.b64decode(data["signed_envelope"])

    # Phase II – Step 6: Verify server signature and parse CHALLENGE + server-ephemeral.pub.
    try:
        signature = signed_envelope[:64]
        message_bytes = signed_envelope[64:]
        server_verify_key.verify(signature, message_bytes)
        server_payload = json.loads(message_bytes.decode("utf-8"))
        print("[AGENT-CRYPTO] Server Signature Verified.")
    except Exception:
        print("[AGENT-CRYPTO] Error: Fake Server Detected!")
        return

    # Extract Data (CHALLENGE, server-ephemeral.pub, session_id).
    challenge = base64.b64decode(server_payload["challenge"])
    server_eph_pub_bytes = base64.b64decode(server_payload["server_eph_pub"])
    server_eph_pub = x25519.X25519PublicKey.from_public_bytes(server_eph_pub_bytes)
    session_id = server_payload["session_id"]

    # Phase II – Step 7: Generate agent-ephemeral key pair.
    agent_eph_pri = x25519.X25519PrivateKey.generate()
    agent_eph_pub = agent_eph_pri.public_key()

    # Phase II – Step 8: Generate ECDH-based session key.
    shared_secret = agent_eph_pri.exchange(server_eph_pub)
    ecdh_key = derive_session_key(shared_secret)

    # Phase II – Step 9: Solve CHALLENGE to produce CHALLENGE_RESPONSE.
    challenge_response = hashlib.sha256(challenge).digest()

    # Phase II – Step 10: Prepare Inner Box (Crypto-Box).
    inner_payload = {
        "challenge_response": base64.b64encode(challenge_response).decode("utf-8"),
        "agent_pub_long_term": AGENT_PUB_HEX,
        "device_attestations": {
            "os": platform.system(),
            "release": platform.release(),
            "hostname": platform.node(),
        },
        "secret_message": "Hello Server (cryptography version), this is a secure trust channel!",
    }

    aead = ChaCha20Poly1305(ecdh_key)
    nonce = os.urandom(12)
    ciphertext = aead.encrypt(nonce, json.dumps(inner_payload).encode("utf-8"), None)
    encrypted_inner_b64 = base64.b64encode(nonce + ciphertext).decode("utf-8")

    # Phase II – Step 11: Prepare Outer Box (wrap Inner Box + agent-ephemeral.pub).
    agent_eph_pub_bytes = agent_eph_pri.public_key().public_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PublicFormat.Raw,
    )
    outer_payload = {
        "session_id": session_id,
        "inner_box": encrypted_inner_b64,
        "agent_eph_pub": base64.b64encode(agent_eph_pub_bytes).decode("utf-8"),
    }

    # Sign Outer Box with Agent Long-term Key
    outer_bytes = json.dumps(outer_payload).encode("utf-8")
    outer_sig = AGENT_PRI.sign(outer_bytes)
    signed_outer = outer_sig + outer_bytes

    # Phase II – Step 12: Forward Outer Box (signed) to the server.
    final_payload = {
        "outer_envelope": base64.b64encode(signed_outer).decode("utf-8"),
        "device_id": device_id,
    }

    print("[AGENT-CRYPTO] Sending encrypted proofs...")
    res = requests.post(
        f"{SERVER_URL}/handshake/verify",
        json=final_payload,
        timeout=5,
    )
    res.raise_for_status()
    verify_result = res.json()
    print(f"[AGENT-CRYPTO] Server Handshake Response: {verify_result}")

    if verify_result.get("status") != "trusted":
        print("[AGENT-CRYPTO] Handshake failed; aborting secure message.")
        return

    session_id = verify_result["session_id"]

    # Post-Handshake: Use established session key for secure application messages.
    secure_box = ChaCha20Poly1305(ecdh_key)
    message = "Hello Server (cryptography version), this is a post-handshake secure message."
    nonce2 = os.urandom(12)
    ct2 = secure_box.encrypt(nonce2, message.encode("utf-8"), None)
    ciphertext_b64 = base64.b64encode(nonce2 + ct2).decode("utf-8")

    secure_payload = {
        "session_id": session_id,
        "ciphertext": ciphertext_b64,
    }

    print("[AGENT-CRYPTO] Sending secure message over session...")
    secure_res = requests.post(
        f"{SERVER_URL}/secure_message",
        json=secure_payload,
        timeout=5,
    )
    secure_res.raise_for_status()
    print(f"[AGENT-CRYPTO] Secure message response: {secure_res.json()}")


if __name__ == "__main__":
    run_agent()


