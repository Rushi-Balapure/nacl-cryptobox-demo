import base64
import binascii
import json
import os
import uuid
import hashlib

from flask import Flask, request, jsonify
from cryptography.hazmat.primitives.asymmetric import ed25519, x25519
from cryptography.hazmat.primitives import serialization, hashes
from cryptography.hazmat.primitives.kdf.hkdf import HKDF
from cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305


app = Flask(__name__)

# --- CONFIGURATION ---
# Load Long-Term Server Private Key (Ed25519), generated by keygen_crypto.py
with open("server_crypto.pri", "rb") as f:
    _server_priv_hex = f.read().strip()
_server_priv_bytes = binascii.unhexlify(_server_priv_hex)
SERVER_PRI = ed25519.Ed25519PrivateKey.from_private_bytes(_server_priv_bytes)
SERVER_PUB = SERVER_PRI.public_key()

# Simple on-disk device registry (for demo purposes only)
DEVICE_REGISTRY_PATH = "devices_crypto.json"


def load_device_registry():
    """Load device registry from disk."""
    if not os.path.exists(DEVICE_REGISTRY_PATH):
        return {}
    with open(DEVICE_REGISTRY_PATH, "r", encoding="utf-8") as f:
        return json.load(f)


def save_device_registry(registry):
    """Persist device registry to disk."""
    with open(DEVICE_REGISTRY_PATH, "w", encoding="utf-8") as f:
        json.dump(registry, f, indent=2)


# In-memory cache of devices: device_id -> {public_key_hex, info, revoked}
devices = load_device_registry()

# Store session data (In prod, use Redis/DB). Maps session_id ->
#   {
#       'challenge': bytes,
#       'server_eph_pri': X25519PrivateKey,
#       'device_id': str,
#       'ecdh_key': bytes | None
#   }
session_store = {}

# --- Registration Shared Secret (REG_TOKEN) ---
# In a real system this is generated per-device in an admin portal and
# communicated out-of-band. For this demo we read it from the environment
# or fall back to a static value.
REG_TOKEN = os.environ.get("REG_TOKEN", "demo-reg-token-1234")


def derive_binding_key(reg_token: str) -> bytes:
    """
    Derive a 32-byte symmetric key from the REG_TOKEN using HKDF,
    matching the registration KDF described in the README.
    """
    hkdf = HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=b"registration_v1",
        info=b"device_binding",
    )
    return hkdf.derive(reg_token.encode("utf-8"))


REG_BINDING_KEY = derive_binding_key(REG_TOKEN)
REG_HANDLE = hashlib.sha256(REG_BINDING_KEY).hexdigest()[:32]
used_reg_handles = set()


def derive_session_key(shared_secret: bytes) -> bytes:
    """
    Derive a 32-byte symmetric key from an X25519 shared secret.
    """
    hkdf = HKDF(
        algorithm=hashes.SHA256(),
        length=32,
        salt=None,
        info=b"device-trust-ecdh",
    )
    return hkdf.derive(shared_secret)


@app.route("/server_pub", methods=["GET"])
def server_public_key():
    """
    Expose the server's long-term public key so agents can fetch it.
    In a real deployment you'd still pin or verify this key out of band.
    """
    server_pub_bytes = SERVER_PUB.public_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PublicFormat.Raw,
    )
    server_pub_hex = binascii.hexlify(server_pub_bytes).decode()
    return jsonify({"server_public_key": server_pub_hex})


@app.route("/register_device", methods=["POST"])
def register_device():
    """
    Phase I – Steps 2 & 3 (Server side):
    Secure device registration using a REG_TOKEN-derived binding key.

    Expects JSON:
    {
        "reg_handle": "<opaque handle derived from REG_TOKEN>",
        "encrypted_payload": "<base64-encoded nonce+ciphertext>"
    }
    """
    data = request.json or {}
    reg_handle = data.get("reg_handle")
    encrypted_payload_b64 = data.get("encrypted_payload")

    if not reg_handle or not encrypted_payload_b64:
        return jsonify({"error": "reg_handle and encrypted_payload are required"}), 400

    # One-time use and handle validation
    if reg_handle != REG_HANDLE or reg_handle in used_reg_handles:
        return jsonify({"error": "invalid or already used registration handle"}), 403

    try:
        encrypted = base64.b64decode(encrypted_payload_b64)
        nonce, ciphertext = encrypted[:12], encrypted[12:]
        aead = ChaCha20Poly1305(REG_BINDING_KEY)
        decrypted_bytes = aead.decrypt(nonce, ciphertext, None)
        payload = json.loads(decrypted_bytes.decode("utf-8"))
    except Exception as e:
        return jsonify({"error": f"decryption failed: {e}"}), 403

    device_pub = payload.get("device_public_key")
    device_info = payload.get("device_info", {})

    if not device_pub:
        return jsonify({"error": "device_public_key missing in decrypted payload"}), 400

    # Basic sanity check: hex string length for Ed25519 public key (32 bytes -> 64 hex chars)
    if not isinstance(device_pub, str) or len(device_pub) != 64:
        return jsonify({"error": "device_public_key must be a 64-char hex string"}), 400

    device_id = uuid.uuid4().hex
    devices[device_id] = {
        "public_key_hex": device_pub,
        "info": device_info,
        "revoked": False,
    }
    save_device_registry(devices)

    # Mark this handle as used to prevent replay of the same REG_TOKEN binding.
    used_reg_handles.add(reg_handle)

    return jsonify(
        {
            "device_id": device_id,
            "message": "Device registered",
        }
    )


@app.route("/handshake/init", methods=["POST"])
def init_handshake():
    """
    Phase II – Steps 4 & 5:
    Generate CHALLENGE and server-ephemeral key pair, then send a signed packet
    to the Agent containing these values.
    """

    data = request.json or {}
    device_id = data.get("device_id")
    if not device_id:
        return jsonify({"error": "device_id is required"}), 400

    device_record = devices.get(device_id)
    if not device_record or device_record.get("revoked"):
        return jsonify({"error": "Unknown or revoked device"}), 403

    # Phase II – Step 4: Generate CHALLENGE and server-ephemeral key pair (X25519).
    challenge = os.urandom(32)
    server_eph_pri = x25519.X25519PrivateKey.generate()
    server_eph_pub = server_eph_pri.public_key()

    session_id = base64.b64encode(os.urandom(8)).decode("utf-8")

    # Store private parts for later verification
    session_store[session_id] = {
        "challenge": challenge,
        "server_eph_pri": server_eph_pri,
        "device_id": device_id,
        "ecdh_key": None,
    }

    # Phase II – Step 5: Prepare payload to send to the Agent.
    server_eph_pub_bytes = server_eph_pub.public_bytes(
        encoding=serialization.Encoding.Raw,
        format=serialization.PublicFormat.Raw,
    )
    payload = {
        "session_id": session_id,
        "challenge": base64.b64encode(challenge).decode("utf-8"),
        "server_eph_pub": base64.b64encode(server_eph_pub_bytes).decode("utf-8"),
    }

    # Sign the payload using Server long-term private key (Ed25519).
    message_bytes = json.dumps(payload).encode("utf-8")
    signature = SERVER_PRI.sign(message_bytes)  # 64-byte Ed25519 signature
    signed_envelope = signature + message_bytes

    return jsonify(
        {
            "signed_envelope": base64.b64encode(signed_envelope).decode("utf-8"),
        }
    )


@app.route("/handshake/verify", methods=["POST"])
def verify_handshake():
    """
    Phase II – Steps 13–17:
    Verify Agent response, derive the shared session key, decrypt the Inner Box,
    perform anti-MITM binding checks, and validate the CHALLENGE_RESPONSE.
    """
    data = request.json or {}
    outer_envelope_b64 = data.get("outer_envelope")
    device_id = data.get("device_id")

    if not outer_envelope_b64 or not device_id:
        return jsonify({"status": "failed", "error": "outer_envelope and device_id are required"}), 400

    device_record = devices.get(device_id)
    if not device_record or device_record.get("revoked"):
        return jsonify({"status": "failed", "error": "Unknown or revoked device"}), 403

    device_pub_hex = device_record["public_key_hex"]
    device_pub_bytes = binascii.unhexlify(device_pub_hex)
    verify_key = ed25519.Ed25519PublicKey.from_public_bytes(device_pub_bytes)

    outer_envelope = base64.b64decode(outer_envelope_b64)

    try:
        # Phase II – Step 13: Verify outer box signature using Agent's long-term public key.
        signature = outer_envelope[:64]
        outer_bytes = outer_envelope[64:]
        verify_key.verify(signature, outer_bytes)

        outer_box_content = json.loads(outer_bytes.decode("utf-8"))

        session_id = outer_box_content["session_id"]
        if session_id not in session_store:
            return "Session invalid", 400

        # Retrieve stored context (server-ephemeral.pri, original CHALLENGE).
        server_eph_pri = session_store[session_id]["server_eph_pri"]
        original_challenge = session_store[session_id]["challenge"]

        # Extract Agent Ephemeral Public Key (agent-ephemeral.pub).
        agent_eph_pub_bytes = base64.b64decode(outer_box_content["agent_eph_pub"])
        agent_eph_pub = x25519.X25519PublicKey.from_public_bytes(agent_eph_pub_bytes)

        # Phase II – Step 14: Compute shared ECDH key (session key material).
        shared_secret = server_eph_pri.exchange(agent_eph_pub)
        ecdh_key = derive_session_key(shared_secret)

        # Save derived session key for later secure API calls
        session_store[session_id]["ecdh_key"] = ecdh_key

        # Phase II – Step 15: Decrypt Inner Box (Crypto-Box) using the session key.
        encrypted_inner_b64 = outer_box_content["inner_box"]
        encrypted_inner = base64.b64decode(encrypted_inner_b64)
        nonce, ciphertext = encrypted_inner[:12], encrypted_inner[12:]
        aead = ChaCha20Poly1305(ecdh_key)
        decrypted_bytes = aead.decrypt(nonce, ciphertext, None)
        inner_data = json.loads(decrypted_bytes.decode("utf-8"))

        print(f"\n[SERVER-CRYPTO] Decrypted Inner Data: {inner_data}")

        # Phase II – Step 16: Verify Agent ID match (anti-MITM binding check).
        agent_pub_inside = inner_data["agent_pub_long_term"]
        if agent_pub_inside != device_pub_hex:
            raise Exception("MITM DETECTED: Outer signature key does not match Inner encrypted ID")

        # Phase II – Step 17: Verify CHALLENGE_RESPONSE and device identity.
        challenge_response = base64.b64decode(inner_data["challenge_response"])
        expected_response = hashlib.sha256(original_challenge).digest()

        if challenge_response != expected_response:
            raise Exception("Challenge Failed")

        print("[SERVER-CRYPTO] SUCCESS: Device Verified and Trusted.")
        print(f"[SERVER-CRYPTO] Device Info: {inner_data['device_attestations']}")
        print(f"[SERVER-CRYPTO] Secret Message: {inner_data['secret_message']}")

        return jsonify(
            {
                "status": "trusted",
                "message": "Connection established",
                "session_id": session_id,
            }
        )

    except Exception as e:
        print(f"[SERVER-CRYPTO] ERROR: {str(e)}")
        return jsonify({"status": "failed", "error": str(e)}), 403


@app.route("/secure_message", methods=["POST"])
def secure_message():
    """
    Example secure endpoint that uses the established session key.

    Expects JSON:
    {
        "session_id": "...",
        "ciphertext": "<base64-encoded nonce+ciphertext>"
    }
    """
    data = request.json or {}
    session_id = data.get("session_id")
    ciphertext_b64 = data.get("ciphertext")

    if not session_id or not ciphertext_b64:
        return jsonify({"error": "session_id and ciphertext are required"}), 400

    session = session_store.get(session_id)
    if not session or not session.get("ecdh_key"):
        return jsonify({"error": "Unknown or untrusted session"}), 403

    ecdh_key = session["ecdh_key"]
    aead = ChaCha20Poly1305(ecdh_key)

    encrypted = base64.b64decode(ciphertext_b64)
    nonce, ciphertext = encrypted[:12], encrypted[12:]

    try:
        plaintext_bytes = aead.decrypt(nonce, ciphertext, None)
        plaintext = plaintext_bytes.decode("utf-8")
        print(f"[SERVER-CRYPTO] Received secure message for session {session_id}: {plaintext}")
        return jsonify({"status": "ok", "echo": plaintext})
    except Exception as e:
        print(f"[SERVER-CRYPTO] ERROR while decrypting secure message: {e}")
        return jsonify({"status": "failed", "error": "Decryption failed"}), 400


if __name__ == "__main__":
    print("Crypto-based server running on port 5001...")
    # Use a different port so it can coexist with the NaCl demo if needed
    app.run(host="0.0.0.0", port=5001, debug=True)


